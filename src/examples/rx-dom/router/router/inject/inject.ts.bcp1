import {
  IMatchingResolvedRXRoute, IResolvedRXRoute, IRXRouteComponent, IRXRouterOutletElement,
} from '../rx-route/rx-route';
import { nodeAppendChild, nodeRemove, nodeRemoveChild } from '@lifaon/rx-dom';
import {
  createMulticastReplayLastSource, IMulticastReplayLastSource, IObservable, let$$, noop, sourceToReadonlySource,
} from '@lifaon/rx-js-light';
import { IRouteParams } from '../route/route-params/route-params.type';




/*--------------------------*/



// export async function injectResolvedRXRoute(
//   route: IResolvedRXRoute,
//   routerOutletElement: IRXRouterOutletElement,
//   signal: AbortSignal,
// ): Promise<IUndoInjectMatchingResolvedRXRouteFunction> {
//   if (route.state === 'matching') {
//     return injectMatchingResolvedRXRoute(
//       route,
//       routerOutletElement,
//       signal,
//     );
//   }
// }

export interface IDestroyInjectMatchingResolvedRXRouteFunction {
  (id: string): void;
}


export async function injectMatchingResolvedRXRoute(
  {
    params,
    childRoute,
    extra,
  }: IMatchingResolvedRXRoute,
  routerOutletElement: IRXRouterOutletElement,
  signal: AbortSignal, // TODO support signal
  id: string,
): Promise<IDestroyInjectMatchingResolvedRXRouteFunction> {
  let destroyComponent: IDestroyInjectMatchingResolvedRXRouteFunction = noop;

  const {
    locateRXRouterOutletElement,
    loadComponent,
    forceComponentReload,
  } = extra;

  if (loadComponent !== null) {
    const component: IRXRouteComponent = await loadComponent(signal);
    const routerOutletInjectedElement: Element | null = routerOutletElement.firstElementChild;

    if (
      forceComponentReload
      || (routerOutletInjectedElement === null)
      || (routerOutletInjectedElement.constructor !== component)
    ) {
      const componentElement: Element = createAndAppendComponent(routerOutletElement, component);
      destroyComponent = (): void => {
        nodeRemove(componentElement);
      };
    } else {
      destroyComponent = (_id: string): void => {
        if ((_id !== id) && (routerOutletInjectedElement !== null)) {
          nodeRemove(routerOutletInjectedElement);
        }
      };
    }
  }

  let destroyChildRoute: IDestroyInjectMatchingResolvedRXRouteFunction = noop;

  if (childRoute !== null) {
    destroyChildRoute = await injectMatchingResolvedRXRoute(
      childRoute,
      (loadComponent === null)
        ? routerOutletElement
        : await locateRXRouterOutletElement(routerOutletElement, signal),
      signal,
      id,
    );
  }

  return (id: string): void => {
    destroyChildRoute(id);
    destroyComponent(id);
  };
}







/* PARAMS */

const COMPONENT_PARAMS = new WeakMap<Element, IMulticastReplayLastSource<IRouteParams>>();

function getRouteParamsSource(
  component: Element,
): IMulticastReplayLastSource<IRouteParams> {
  let $routeParams$: IMulticastReplayLastSource<IRouteParams> | undefined = COMPONENT_PARAMS.get(component);
  if ($routeParams$ === void 0) {
    $routeParams$ = createMulticastReplayLastSource<IRouteParams>();
  }
  return $routeParams$;
}

function setRouteParams(
  component: Element,
  params: IRouteParams,
): void {
  return getRouteParamsSource(component).emit(params);
}

export function getRouteParams(
  component: Element,
): IObservable<IRouteParams> {
  return getRouteParamsSource(component).subscribe;
}



function createAndAppendComponent(
  routerOutletElement: Element,
  component: IRXRouteComponent,
): Element {
  return nodeAppendChild(routerOutletElement, new component());
}
